/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package client;

/**
 *
 * @author user
 */
import java.awt.Dimension;
import java.awt.event.KeyEvent;
import java.util.Date;

import javax.swing.SwingUtilities;

import diet.client.ConnectionToServer;
import diet.message.MessageTask;
import diet.task.ClientTaskEventHandler;
import diet.task.mazegame.message.*;

/**
 * This deals with events generated by the maze game, local client keyboard input and maze game messages received
 * from the server.
 * <p>It unpacks messages from the server and generates messages to be sent to the server. 
 * 
 *
 * @author user
 */
public class ClientMazeGameComms extends ClientTaskEventHandler {
  //private ConnectionToServer cts;
  //private Socket kkSocket = null;
  //ObjectOutputStream out = null;
  //ObjectInputStream in = null;
  JMazeFrame jmf;
 
  Game gam ;// = new Game("Empty");
  String dispMessage = null;
  //String serverName;
  //int isDirector=0;//0 if dyadic. 
                   //1 if triadic and client is director. 
                   //2 if triadic and client is not director
  Date timeOfLastKeyPress = new Date();

  public ClientMazeGameComms(ConnectionToServer cts,MessageNewMazeGame mng){
      super(cts);
      try{
        
        jmf = new JMazeFrame();
        System.err.println("HEREB2");
        jmf.setComms(this);
        System.err.println("HEREB3");
        jmf.setVisible(true);
        System.err.println("HEREB4");
        processNewGameRequest(mng);
        System.err.println("HEREB5");
        //this.setDisplayMessage("Waiting for other computers to connect....");
        
      }catch (Exception e){
          System.err.println(e.getMessage().toString());
          System.out.println("STACKTRACE:");
          e.printStackTrace();
      }  
  }
  
  public void repaintJMazeFrame(){
      try{
            SwingUtilities.invokeLater(new Runnable(){
                public void run(){
                     jmf.jPanel1.repaint();
                }
            });  
  }catch(Exception e){
              System.err.println("ERROR REPAINTING MAZE "+e.getMessage().toString());
   }
}  

  /**
   * Processes messages that arrive from the server. The types and contents of these 
   * messages are used to determine appropriate updates to the local maze game.
   * @param mt
   */
  public void processTaskMove(MessageTask mt){
       if (mt instanceof MessageChangeGateStatus) {
          final MessageChangeGateStatus mscgs = (MessageChangeGateStatus) mt;
          jmf.jPanel1.maz.gatesOpen = mscgs.gatesAreOpen();
          repaintJMazeFrame();
          //this.setDisplayMessage(null);
        }
        else if (mt instanceof MessageNextMaze_SentAsIndex) {
          MessageNextMaze_SentAsIndex mnm = (MessageNextMaze_SentAsIndex)mt;
          System.err.println("ATTEMPTING TO MOVE MAZE TO: "+mnm.getNext());
          processNextGameRequest(mnm.getNext(),mnm.getGame(),mnm.getDisplayText());
        }
        else if (mt instanceof MessageNextMaze_SentAsMaze) { //Dont use this
          //MessageNextMaze_SentAsMaze mnMaze = (MessageNextMaze_SentAsMaze)mt;
          //System.err.println("ATTEMPTING TO MOVE MAZE TO: "+mnm.getNext());
         // processNextGameRequest(mnm.getNext());
          
        }
        else if (mt instanceof MessageStartGame){
          MessageStartGame msg = (MessageStartGame) mt;
          this.setDisplayMessage(null);
          repaintJMazeFrame();
        }
        else if (mt instanceof MessageWaitForOthersToCatchUp){
          MessageWaitForOthersToCatchUp msg = (MessageWaitForOthersToCatchUp) mt;
          this.setDisplayMessage(msg.getText());
          repaintJMazeFrame();
        }
       
  }


  

  /**
   * Constructs a message containing the position of the marker within the maze game.
   * @param d2
   */
  public void sendCursorPos(Dimension d2) {
       int mazeGsmeNo =-1;
      try {
      
      try{
        mazeGsmeNo = gam.getAllMazes().indexOf(jmf.jPanel1.maz);
      }catch (Exception e){
          e.printStackTrace();   
      }  
      MessageCursorUpdate mscu = new MessageCursorUpdate(cts.getEmail(),cts.getUsername(), d2, mazeGsmeNo);
      
      
      
      cts.sendMessage(mscu);
      //out.writeObject(mscu);
      //out.flush();
    }
    catch (Exception e) {
      System.out.println(e.getMessage());
    }

  }

  /**
   * Receives keypresses typed locally by the client and relays them to the maze game. 
   * Initial filtering of keypresses is handled by @link ClientEventHandler.
   * @param e
   */
  public void relayKeypressToMazeFrame(KeyEvent e){
      jmf.keyPressFilter(e);
  }
  
  /**
   * Receives the keycodes of the keys typed locally by the client and relays them to the maze game. 
   * Initial filtering of keypresses is handled by {@link diet.client.ClientEventHandler}.
   * 
   * @param e key pressed
   */
  public void relayKeyReleaseFilterToMazeFrame(KeyEvent e){
      jmf.keyReleaseFilter(e);
  }
  
  /**
   * Returns the String currently being displayed in the Maze Game window (distinct from the JChatFrame)
   * @return message displayed in the maze game window
   */
  public String getDisplayMessage() {
    return this.dispMessage;
  }

  /**
   * Displays the String in the Maze Game window
   * @param msg
   */
  public void setDisplayMessage(String msg) {
    dispMessage = msg;
    jmf.jPanel1.paint(jmf.jPanel1.getGraphics());
    
  }

  /**
   * Retrieves list of mazes from message sent by server and initializes the maze game to the first maze.
   * @param msng
   */
  private void processNewGameRequest(MessageNewMazeGame msng) {
    System.err.println("HEREC1");
    gam = msng.getGame();
    System.err.println("HEREC2");
    //gam.clientName = cts.getUsername();
    System.err.println("HEREC3");
    jmf.jPanel1.maz = gam.getMazeNo(0);
    System.err.println("HEREC4");
    jmf.jPanel1.resetCursorToBegin();
    System.err.println("HEREC5");
    jmf.jPanel1.paint(jmf.jPanel1.getGraphics());
    System.err.println("HEREC6");
    jmf.jPanel1.resetCursorToBegin();
    System.err.println("HEREC7");
    
  }

  public void debugMoveCursorToGOAL(){
      jmf.jPanel1.maz.moveTo(new Dimension(jmf.jPanel1.maz.finish.x, jmf.jPanel1.maz.finish.y));
      jmf.cms.sendCursorPos(new Dimension(jmf.jPanel1.maz.current.x, jmf.jPanel1.maz.current.y));
  }
   
  
  
  
  
  public void displayMessageInWindow(String text, long lengthOfTime){
       setDisplayMessage(text);
       repaintJMazeFrame();
       try {
          if(lengthOfTime>0)this.sleep(lengthOfTime);
       }
       catch (Exception e) {}
       if(lengthOfTime>0)setDisplayMessage(null);
  }
  
  
  
  /**
   * Called when all participants in maze game are on their respective goals. Selects and displays the next maze
   * in the Vector of stored mazes
   * @param i
   */
  private void processNextGameRequest(int i, Game g, String message) {
   try{
    if(g!=null){
        this.gam=g;
    }   
       
    int maxGameNo = gam.getAllMazes().size();
    jmf.jPanel1.maz = (Maze)gam.getAllMazes().elementAt(i);//gam.nextMaze();
    jmf.jPanel1.resetCursorToBegin();
    setDisplayMessage(message);
    repaintJMazeFrame();
    try {
      this.sleep(2000);
    }
    catch (Exception e) {}
    setDisplayMessage(null);
    jmf.jPanel1.resetCursorToBegin();
    jmf.jPanel1.maz.moveTo(new Dimension(0,0));
    jmf.jPanel1.maz.changeGates(false);
    
    System.out.println("processing next game request");
    repaintJMazeFrame();
   }catch (Exception e){
       System.err.println("ERROR PROCESSING NEXT GAME REQUEST: "+i);
   } 
  }

  private void resetWaitingForNextExperiment() {
    setDisplayMessage("Experiment Finished.");
    try {
      this.sleep(1000);
    }
    catch (Exception e) {}

  }
  
   public void closeDown(){
     try{
       jmf.setVisible(false);
       jmf.dispose();
       jmf = null;
     }catch (Exception e){
        System.err.println("Could not close down the maze properly: "+e.getMessage());
     }  
   }
  
}
